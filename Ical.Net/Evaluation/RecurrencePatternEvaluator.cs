//
// Copyright ical.net project maintainers and contributors.
// Licensed under the MIT license.
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Ical.Net.DataTypes;
using NodaTime;
using NodaTime.Calendars;
using NodaTime.Extensions;

namespace Ical.Net.Evaluation;

public class RecurrencePatternEvaluator : Evaluator
{
    protected RecurrencePattern Pattern { get; set; }

    public RecurrencePatternEvaluator(RecurrencePattern pattern)
    {
        Pattern = pattern;
    }

    private RecurrencePattern ProcessRecurrencePattern(CalDateTime referenceDate)
    {
        var r = new RecurrencePattern();
        r.CopyFrom(Pattern);

        if (referenceDate.HasTime)
        {
            if (r.Frequency > FrequencyType.Secondly && r.BySecond.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.BySecond.Add(referenceDate.Second);
            }
            if (r.Frequency > FrequencyType.Minutely && r.ByMinute.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByMinute.Add(referenceDate.Minute);
            }
            if (r.Frequency > FrequencyType.Hourly && r.ByHour.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByHour.Add(referenceDate.Hour);
            }
        }
        else
        {
            // The BYSECOND, BYMINUTE and BYHOUR rule parts MUST NOT be specified
            // when the associated "DTSTART" property has a DATE value type.
            // These rule parts MUST be ignored in RECUR value that violate the
            // above requirement(e.g., generated by applications that pre - date
            // this revision of iCalendar).
            r.BySecond.Clear();
            r.BySecond.Add(0);
            r.ByMinute.Clear();
            r.ByMinute.Add(0);
            r.ByHour.Clear();
            r.ByHour.Add(0);
        }

        // If BYDAY, BYYEARDAY, or BYWEEKNO is specified, then
        // we don't default BYDAY, BYMONTH or BYMONTHDAY
        if (r.ByDay.Count == 0)
        {
            // If the frequency is weekly, use the original date's day of week.
            // NOTE: fixes WeeklyCount1() and WeeklyUntil1() handling
            // If BYWEEKNO is specified and BYMONTHDAY/BYYEARDAY is not specified,
            // then let's add BYDAY to BYWEEKNO.
            // NOTE: fixes YearlyByWeekNoX() handling
            if (r.Frequency == FrequencyType.Weekly || (r.ByWeekNo.Count > 0 && r.ByMonthDay.Count == 0 && r.ByYearDay.Count == 0))
            {
                r.ByDay.Add(new WeekDay(referenceDate.DayOfWeek));
            }

            // If BYMONTHDAY is not specified,
            // default to the current day of month.
            // NOTE: fixes YearlyByMonth1() handling, added BYYEARDAY exclusion
            // to fix YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Weekly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonthDay.Count == 0)
            {
                r.ByMonthDay.Add(referenceDate.Day);
            }

            // If BYMONTH is not specified, default to
            // the current month.
            // NOTE: fixes YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Monthly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonth.Count == 0)
            {
                r.ByMonth.Add(referenceDate.Month);
            }
        }

        // Pre-order those BY values that don't allow for negative values. Those with negative values can only
        // be ordered once the individual position is known.
        if (r.BySecond.Count > 0) r.BySecond = r.BySecond.OrderBy(x => x).ToList();
        if (r.ByMinute.Count > 0) r.ByMinute = r.ByMinute.OrderBy(x => x).ToList();
        if (r.ByHour.Count > 0) r.ByHour = r.ByHour.OrderBy(x => x).ToList();
        if (r.ByMonth.Count > 0) r.ByMonth = r.ByMonth.OrderBy(x => x).ToList();

        return r;
    }

    /// <summary>
    /// Returns a list of start dates in the specified period represented by this recurrence pattern.
    /// This method includes a base date argument, which indicates the start of the first occurrence of this recurrence.
    /// The base date is used to inject default values to return a set of dates in the correct format.
    /// For example, if the search start date (start) is Wed, Mar 23, 12:19PM, but the recurrence is Mon - Fri, 9:00AM - 5:00PM,
    /// the start dates returned should all be at 9:00AM, and not 12:19PM.
    /// </summary>
    private IEnumerable<ZonedDateTime> GetDates(CalDateTime seed, DateTimeZone timeZone, Instant? periodStart, RecurrencePattern pattern,
         EvaluationOptions? options)
    {
        // Floating values should be evaluated in the given time zone.
        // Other values should be evaluated in their time zone and then
        // converted to the given time zone.
        var originalDate = seed.AsZonedOrDefault(timeZone);

        var seedCopy = originalDate;

        var periodStartDt = periodStart?.InZone(originalDate.Zone);

        var weekYearRule = GetWeekYearRule(pattern);

        if ((pattern.Frequency == FrequencyType.Yearly) && (pattern.ByWeekNo.Count != 0))
        {
            // Dates in the first or last week of the year could belong weeks that belong to
            // the prev/next year, in which case we must adjust that year. This is necessary
            // to get the intervals right.
            IncrementDate(ref seedCopy, pattern, weekYearRule.GetWeekYear(seedCopy.Date) - seedCopy.Year);
        }

        // optimize the start time for selecting candidates
        // (only applicable where a COUNT is not specified)
        if (pattern.Count is null && periodStartDt is not null)
        {
            var incremented = seedCopy;
            while (incremented.ToInstant() < periodStartDt.Value.ToInstant())
            {
                seedCopy = incremented;
                IncrementDate(ref incremented, pattern, pattern.Interval);
            }
        }
        else
        {
            if (pattern.Count < 1)
                throw new Exception("Count must be greater than 0");
        }

        // Do the enumeration in a separate method, as it is a generator method that is
        // only executed after enumeration started. In order to do most validation upfront,
        // do as many steps outside the generator as possible.
        return EnumerateDates(originalDate, seedCopy, pattern, options)
            .Select(x => x.WithZone(timeZone));
    }

    private IEnumerable<ZonedDateTime> EnumerateDates(ZonedDateTime originalDate, ZonedDateTime intervalRefTime, RecurrencePattern pattern, EvaluationOptions? options)
    {
        var expandBehavior = RecurrenceUtil.GetExpandBehaviorList(pattern);

        var searchEndDate = GetSearchEndDate(pattern, originalDate.Zone);

        var noCandidateIncrementCount = 0;

        var dateCount = 0;

        while (true)
        {
            var lowerLimit = GetIntervalLowerLimit(intervalRefTime, pattern, originalDate);

            if (searchEndDate != null && searchEndDate.Value.ToInstant() < lowerLimit.ToInstant())
                break;

            var seedDate = (lowerLimit.ToInstant() > intervalRefTime.ToInstant()) ? lowerLimit : intervalRefTime;
            var candidates = GetCandidates(originalDate.Zone, seedDate, pattern, expandBehavior);

            foreach (var candidate in candidates.Where(t => t.ToInstant() >= originalDate.ToInstant()))
            {
                noCandidateIncrementCount = 0;

                // candidates MAY occur before periodStart
                // For example, FREQ=YEARLY;BYWEEKNO=1 could return dates
                // from the previous year.

                yield return candidate;

                if (++dateCount >= pattern.Count)
                    yield break;
            }

            if (noCandidateIncrementCount > options?.MaxUnmatchedIncrementsLimit)
                throw new EvaluationLimitExceededException();

            noCandidateIncrementCount++;

            IncrementDate(ref intervalRefTime, pattern, pattern.Interval);
        }
    }

    private static ZonedDateTime? GetSearchEndDate(RecurrencePattern pattern, DateTimeZone timeZone)
    {
        // This value is only used for performance reasons to stop incrementing after
        // until is passed, even if no recurrences are being found.
        // As a safe heuristic we add 1d to the UNTIL value to cover any time shift and DST changes.
        // It's just important that we don't miss any recurrences, not that we stop exactly at UNTIL.
        // Precise UNTIL handling is done outside this method after TZ conversion.
        var coarseUntil = pattern.Until?.ToZonedDateTime(timeZone)
            .LocalDateTime
            .PlusDays(1)
            .InZoneLeniently(timeZone);

        return coarseUntil;
    }

    /// <summary>
    /// Find the lowest possible date/time for a recurrence in the given interval.
    /// </summary>
    /// <remarks>
    /// For most frequencies the interval's lower limit is simply the provided
    /// <paramref name="intervalRefTime"/>. YEARLY rules require special handling:
    /// - If BYMONTH is present and BYWEEKNO is not, an occurrence for the interval
    ///   might fall earlier in the year than the intervalRefTime's month/day. In
    ///   that case we compute the earliest possible date/time that could be
    ///   generated for the interval (earliest month/day/hour/minute/second).
    /// - If neither BYMONTH nor BYWEEKNO is present, we use the original date's month
    /// - If only BYWEEKNO is present, the interval may contain days from the previous
    ///   or next year (ISO week boundaries). In that case we adjust the interval
    ///   start to the first day of the configured week so we don't miss candidates
    ///   that belong to the week containing Jan 1st.
    /// </remarks>
    private static ZonedDateTime GetIntervalLowerLimit(ZonedDateTime intervalRefTime, RecurrencePattern pattern, ZonedDateTime originalDate)
    {
        switch (pattern)
        {
            case { Frequency: FrequencyType.Yearly, ByMonth.Count: 0, ByWeekNo.Count: 0 }:
            {
                // Return intervalRefTime but use the month from the original DTSTART.
                // Else, the earliest candidate for the interval might be too early
                // Do this by shifting the intervalRefTime by the difference in months.
                // This preserves the day/time from intervalRefTime and relies on AddMonths
                // to perform month-end semantics (e.g. Jan 31 -> Feb 28/29) instead of
                // manually clamping the day.
                var monthDelta = originalDate.Month - intervalRefTime.Month;
                return intervalRefTime.LocalDateTime
                    .PlusMonths(monthDelta)
                    .InZoneLeniently(intervalRefTime.Zone);
            }

            case { Frequency: FrequencyType.Yearly, ByMonth.Count: > 0, ByWeekNo.Count: 0 }:
            {
                // When evaluating a YEARLY rule that restricts months (BYMONTH) but not
                // week numbers, it's possible that the earliest candidate inside the
                // interval is in an earlier month/day than `intervalRefTime` (for example
                // BYMONTH=1 while intervalRefTime is anchored on a later month). To avoid
                // terminating enumeration prematurely (with a coarse UNTIL cutoff), compute
                // the earliest plausible date/time for this interval and use that as the
                // lower limit.
                //
                // We pick:
                //  - year = intervalRefTime.Year
                //  - month = smallest BYMONTH or the original DTSTART month if BYMONTH absent
                //  - day = smallest BYMONTHDAY (clamped to daysInMonth) or original DTSTART day
                //  - time components = smallest BYHOUR/BYMINUTE/BYSECOND or original DTSTART time
                //
                // This is a conservative earliest-possible candidate; it must not exclude
                // any valid occurrence for the interval.
                var year = intervalRefTime.Year;

                // Determine the earliest month we could possibly generate for this interval.
                var month = pattern.ByMonth.Min();

                // Determine an appropriate day in the month.
                var daysInMonth = CalendarSystem.Iso.GetDaysInMonth(year, month);
                int day;
                if (pattern.ByMonthDay.Count > 0)
                {
                    // Map BYMONTHDAY entries (positive and negative) to absolute days
                    // in the target month, then pick the smallest. This handles cases
                    // where BYMONTHDAY mixes positive and negative values (e.g. 2,-2).
                    var mappedDays = pattern.ByMonthDay
                        .Select(md => md > 0 ? Math.Min(md, daysInMonth) : Math.Max(1, daysInMonth + md + 1));
                    day = mappedDays.Min();
                }
                else
                {
                    // default to original date's day, constrained to the target month length
                    day = Math.Min(originalDate.Day, daysInMonth);
                }

                // Determine earliest time components
                var hour = pattern.ByHour.Count > 0 ? pattern.ByHour.Min() : originalDate.Hour;
                var minute = pattern.ByMinute.Count > 0 ? pattern.ByMinute.Min() : originalDate.Minute;
                var second = pattern.BySecond.Count > 0 ? pattern.BySecond.Min() : originalDate.Second;

                return new LocalDateTime(year, month, day, hour, minute, second)
                    .InZoneLeniently(intervalRefTime.Zone);
            }

            case { Frequency: FrequencyType.Yearly, ByWeekNo.Count: not 0 }:
            {
                // YEARLY with BYWEEKNO: weeks may span year boundaries. Move the
                // interval lower limit to the first day of the week so expansion over
                // the week (including days before Jan 1st) is handled correctly.
                return GetFirstDayOfWeekDate(intervalRefTime.LocalDateTime, pattern.FirstDayOfWeek)
                    .InZoneLeniently(intervalRefTime.Zone);
            }

            default:
            {
                return intervalRefTime;
            }
        }
    }

    private struct ExpandContext
    {
        /// <summary>
        /// True when the candidate set has already been expanded by an earlier BY-* part.
        /// When true, subsequent BY-* parts must only limit/filter, not expand.
        /// </summary>
        /// <example>
        /// BYWEEKNO can expand the candidate set across month and year boundaries. When BYWEEKNO
        /// performs expansion (i.e. the expand behavior is enabled for BYWEEKNO), the evaluator
        /// marks the candidate set as expanded and subsequent BY‑parts must not expand again.
        /// </example>
        public bool IsCandidateSetFullyExpanded { get; set; }
    }

    /// <summary>
    /// Returns a list of possible dates generated from the applicable BY* rules, using the specified date as a seed.
    /// </summary>
    /// <param name="timeZone">Time zone to evaluate candidates for.</param>
    /// <param name="seedDate">The seed date. It is always returned in the list of possible dates.</param>
    /// <param name="pattern"></param>
    /// <param name="expandBehaviors"></param>
    /// <returns>A list of possible dates.</returns>
    private IEnumerable<ZonedDateTime> GetCandidates(DateTimeZone timeZone, ZonedDateTime seedDate, RecurrencePattern pattern, bool?[] expandBehaviors)
    {
        var expandContext = new ExpandContext { IsCandidateSetFullyExpanded = false };

        IEnumerable<ZonedDateTime> dates = [seedDate];
        dates = GetMonthVariants(dates, pattern, expandBehaviors[0]);
        dates = GetWeekNoVariants(dates, pattern, expandBehaviors[1], ref expandContext);
        dates = GetYearDayVariants(dates, pattern, expandBehaviors[2], ref expandContext);
        dates = GetMonthDayVariants(dates, pattern, expandBehaviors[3], ref expandContext);
        dates = GetDayVariants(dates, pattern, expandBehaviors[4], ref expandContext);

        dates = GetHourVariants(dates, pattern, expandBehaviors[5]);
        dates = GetMinuteVariants(dates, pattern, expandBehaviors[6]);
        dates = GetSecondVariants(dates, pattern, expandBehaviors[7]);
        dates = ApplySetPosRules(dates, pattern);

        return dates;
    }

    /// <summary>
    /// Applies BYSETPOS rules to <paramref name="dates"/>. Valid positions are from 1 to the size of the date list. Invalid
    /// positions are ignored.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSETPOS rules will be applied.</param>
    /// <param name="pattern"></param>
    private static IEnumerable<T> ApplySetPosRules<T>(IEnumerable<T> dates, RecurrencePattern pattern)
    {
        // return if no SETPOS rules specified..
        if (pattern.BySetPosition.Count == 0)
            return dates;

        HashSet<int> bySetPos;

        if (pattern.BySetPosition.Any(p => p < 0)) {
            var tmp = dates.ToList();
            var count = tmp.Count;
            dates = tmp;
            bySetPos = [.. pattern.BySetPosition.Select(p => (p < 0) ? count + p + 1 : p)];
        } else {
            bySetPos = [.. pattern.BySetPosition];
        }

        return dates.Where((d, i) => bySetPos.Contains(i + 1));
    }

    /// <summary>
    /// Applies BYMONTH rules specified in this Recur instance to the specified date list. 
    /// If no BYMONTH rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMONTH rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMONTH rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMonthVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByMonth.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(d => pattern.ByMonth
                .Select(month => d.LocalDateTime.PlusMonths(month - d.Month).InZoneLeniently(d.Zone)));
        }

        // Limit behavior
        if (pattern.Frequency == FrequencyType.Weekly)
        {
            // The dates here represent weeks, with each date being the
            // start of a week except for the initial reference date.
            // Return weeks that have any day within BYMONTH.
            return dates.Where(date => pattern.ByMonth.Contains(date.Month)
                || pattern.ByMonth.Contains(date.LocalDateTime.PlusDays(6).InZoneLeniently(date.Zone).Month));
        }

        return dates.Where(date => pattern.ByMonth.Contains(date.Month));
    }

    /// <summary>
    /// Applies BYWEEKNO rules specified in this Recur instance to the specified date list. 
    /// If no BYWEEKNO rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYWEEKNO rules will be applied.</param>
    /// <returns>The modified list of dates after applying the BYWEEKNO rules.</returns>
    private static IEnumerable<ZonedDateTime> GetWeekNoVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByWeekNo.Count == 0)
            return dates;

        Debug.Assert(expand.Value);

        // Expand behavior
        var weekNoDates = GetWeekNoVariantsExpanded(dates, pattern);

        // subsequent parts should only limit, not expand
        expandContext.IsCandidateSetFullyExpanded = true;

        // Apply BYMONTH limit behavior, as we might have expanded over month/year boundaries
        // in this method and BYMONTH has already been applied before, so wouldn't be again.
        return GetMonthVariants(weekNoDates, pattern, expand: false);
    }

    private static IWeekYearRule GetWeekYearRule(RecurrencePattern pattern) =>
        WeekYearRules.ForMinDaysInFirstWeek(4, pattern.FirstDayOfWeek.ToIsoDayOfWeek());

    private static IEnumerable<ZonedDateTime> GetWeekNoVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        var weekYearRule = GetWeekYearRule(pattern);

        foreach (var (t, weekNo) in dates.SelectMany(t => GetByWeekNoForYearNormalized(pattern, t.Year), (t, weekNo) => (t, weekNo)))
        {
            var date = t.LocalDateTime;

            // Make sure we start from a reference date that is in a week that belongs to the current year.
            // It's not important that the date lies in a certain week, but that the week belongs to the
            // current year and that the week day is preserved.
            if (date.Month == 1)
                date = date.PlusDays(7);
            else if (date.Month >= 12)
                date = date.PlusDays(-7);

            // Determine our current week number
            var currWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);

            // Move ahead to the correct week of the year
            date = date.PlusDays((weekNo - currWeekNo) * 7);

            // Ignore the week if it doesn't belong to the current year.
            if (weekYearRule.GetWeekYear(date.Date) != t.Year)
                continue;

            // Step backward single days until we're at the correct DayOfWeek
            date = GetFirstDayOfWeekDate(date, pattern.FirstDayOfWeek);

            foreach (var d in Enumerable.Range(0, 7).Select(i => date.PlusDays(i)))
                yield return d.InZoneLeniently(t.Zone);
        }
    }

    private static LocalDateTime GetFirstDayOfWeekDate(LocalDateTime date, DayOfWeek firstDayOfWeek)
    {
        var first = firstDayOfWeek.ToIsoDayOfWeek();
        if (date.DayOfWeek == first)
        {
            return date;
        }

        return date.Previous(first);
    }

    /// <summary>
    /// Normalize the BYWEEKNO values to be positive integers.
    /// </summary>
    private static List<int> GetByWeekNoForYearNormalized(RecurrencePattern pattern, int year)
    {
        var weeksInYear = new Lazy<int>(() => GetWeekYearRule(pattern).GetWeeksInWeekYear(year));
        return pattern.ByWeekNo
            .Select(weekNo => weekNo >= 0 ? weekNo : weeksInYear.Value + weekNo + 1)
            .OrderBy(x => x)
            .ToList();
    }

    /// <summary>
    /// Applies <c>BYYEARDAY</c> rules from <paramref name="pattern"/> to a sequence of candidate dates.
    /// </summary>
    /// <param name="dates">Sequence of candidate dates (typically interval reference dates or previously-expanded dates).</param>
    /// <param name="pattern">Recurrence pattern containing the <c>BYYEARDAY</c> values.</param>
    /// <param name="expand">
    /// Controls the operation mode:
    /// - <c>true</c>  : perform an expand operation — each input date is expanded into the concrete dates
    ///                  represented by the <c>BYYEARDAY</c> values for that date's year.
    /// - <c>false</c> : perform a limit/filter operation — only return input dates that match any of the
    ///                  <c>BYYEARDAY</c> values for the input date's year.
    /// - <c>null</c>  : no operation, return <paramref name="dates"/> unchanged.
    /// </param>
    /// <param name="expandContext">
    /// Context that indicates whether earlier parts have already fully expanded the candidate set.
    /// If <see cref="ExpandContext.IsCandidateSetFullyExpanded"/> is <c>true</c> then expansion must not be
    /// performed again and the method should behave in limit mode.
    /// When this method performs an expansion it will set <see cref="ExpandContext.IsCandidateSetFullyExpanded"/>
    /// to <c>true</c> to prevent later parts from expanding again.
    /// </param>
    /// <returns>
    /// A sequence of dates after applying the <c>BYYEARDAY</c> rules.
    /// Expanded dates produced for a given input are constrained to the same calendar year as the input date;
    /// out-of-range <c>BYYEARDAY</c> values (e.g. +-366 in non-leap years) are ignored.
    /// </returns>
    private static IEnumerable<ZonedDateTime> GetYearDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand is null || pattern.ByYearDay.Count == 0)
            return dates;

        if ((expand == true) && !expandContext.IsCandidateSetFullyExpanded)
        {
            expandContext.IsCandidateSetFullyExpanded = true;
            return GetYearDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetYearDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetYearDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var date1 = date.LocalDateTime;
            var yearDayDates = new SortedSet<LocalDateTime>(
                pattern.ByYearDay.Select(yearDay => yearDay > 0
                ? date1.PlusDays(-date1.DayOfYear + yearDay)
                : date1.PlusDays(-date1.DayOfYear + 1).PlusYears(1).PlusDays(yearDay))
                // Ignore the BY values that don't fit into the current year (i.e. +-366 in non-leap-years).
                .Where(d => d.Year == date1.Year));

            foreach (var d in yearDayDates)
                yield return d.InZoneLeniently(date.Zone);
        }
    }

    private static IEnumerable<ZonedDateTime> GetYearDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var zonedDate in dates)
        {
            var date = zonedDate.LocalDateTime;
            var candidates =
                from yearDay in pattern.ByYearDay
                let newDate = yearDay > 0
                    ? date.PlusDays(-date.DayOfYear + yearDay)
                    : date.PlusDays(-date.DayOfYear + 1).PlusYears(1).PlusDays(yearDay)
                select newDate;

            if (candidates.Contains(date))
                yield return date.InZoneLeniently(zonedDate.Zone);
        }
    }

    /// <summary>
    /// Applies BYMONTHDAY rules specified in this RecurrencePattern instance to the specified date list. 
    /// If no BYMONTHDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <returns>The modified list of dates after applying the BYMONTHDAY rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMonthDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByMonthDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.IsCandidateSetFullyExpanded)
        {
            expandContext.IsCandidateSetFullyExpanded = true;
            return GetMonthDayVariantsExpanded(dates, pattern);
        }

        // limit behavior
        return GetMonthDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetMonthDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        // Helper that checks whether the given candidate matches any BYMONTHDAY entry
        // taking negative values into account (relative to the month's length).
        static bool MatchesAnyMonthDay(ZonedDateTime candidate, IEnumerable<int> monthDays)
        {
            var daysInMonth = CalendarSystem.Iso.GetDaysInMonth(candidate.Year, candidate.Month);
            foreach (var monthDay in monthDays)
            {
                var byMonthDay = monthDay > 0 ? monthDay : (daysInMonth + monthDay + 1);
                if (candidate.Day == byMonthDay)
                    return true;
            }
            return false;
        }

        foreach (var date in dates)
        {
            // If BYMONTH is specified and this date's month is not included, skip it.
            if (pattern.ByMonth.Count > 0 && !pattern.ByMonth.Contains(date.Month))
                continue;

            if (MatchesAnyMonthDay(date, pattern.ByMonthDay))
                yield return date;
        }
    }

    private static IEnumerable<ZonedDateTime> GetMonthDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var zonedDate in dates)
        {
            var date = zonedDate.LocalDateTime;
            var monthDayDates = new SortedSet<LocalDateTime>(
                from monthDay in pattern.ByMonthDay
                let daysInMonth = CalendarSystem.Iso.GetDaysInMonth(date.Year, date.Month)
                let monthDayAbs = (monthDay > 0) ? monthDay : (daysInMonth + monthDay + 1)
                where (monthDayAbs > 0) && (monthDayAbs <= daysInMonth)
                select date.PlusDays(-date.Day + monthDayAbs));

            foreach (var d in monthDayDates)
                yield return d.InZoneLeniently(zonedDate.Zone);
        }
    }

    /// <summary>
    /// Applies BYDAY rules specified in this Recur instance to the specified date list. 
    /// If no BYDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which BYDAY rules will be applied.</param>
    /// <returns>The modified list of dates after applying BYDAY rules, or the original list if no BYDAY rules are specified.</returns>
    private static IEnumerable<ZonedDateTime> GetDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.IsCandidateSetFullyExpanded)
        {
            // Expand behavior
            expandContext.IsCandidateSetFullyExpanded = true;
            return GetDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
        =>
            // If no offset is specified, simply test the day of week.
            // When an offset is present, use GetAbsWeekDays to compute the concrete
            // weekday dates according to the frequency and check containment.
            dates.Where(date => pattern.ByDay.Any(weekDay =>
            {
                if (weekDay.Offset is null)
                    return weekDay.DayOfWeek.Equals(date.DayOfWeek.ToDayOfWeek());

                // When limiting with an offset (e.g. "22MO" or "1MO"), compute the
                // absolute dates for that WeekDay in the appropriate scope and
                // check if the candidate matches one of them.
                return GetAbsWeekDays(date.LocalDateTime, weekDay, pattern)
                    .Select(x => x.InZoneLeniently(date.Zone))
                    .Any(d => d.Equals(date));
            }));

    private static IEnumerable<ZonedDateTime> GetDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var weekDayDates = new SortedSet<LocalDateTime>();
            foreach (var day in pattern.ByDay)
                foreach (var d in GetAbsWeekDays(date.LocalDateTime, day, pattern))
                    weekDayDates.Add(d);

            foreach (var d in weekDayDates)
                yield return d.InZoneLeniently(date.Zone);
        }
    }

    /// <summary>
    /// Returns a list of applicable dates corresponding to the specified week day in accordance with the frequency
    /// specified by this recurrence rule.
    /// </summary>
    /// <param name="date">The date to start the evaluation from.</param>
    /// <param name="weekDay">The week day to evaluate.</param>
    /// <returns>A list of applicable dates.</returns>
    private static IEnumerable<LocalDateTime> GetAbsWeekDays(LocalDateTime date, WeekDay weekDay, RecurrencePattern pattern)
    {
        var dates = pattern switch
        {
            { Frequency: FrequencyType.Daily } => GetAbsWeekDaysDaily(date, weekDay),
            { Frequency: FrequencyType.Weekly } or { ByWeekNo: { Count: > 0 } } => GetAbsWeekDaysWeekly(date, pattern, weekDay),
            { Frequency: FrequencyType.Monthly } or { ByMonth: { Count: > 0 } } => GetAbsWeekDaysMonthly(date, pattern, weekDay),
            { Frequency: FrequencyType.Yearly } => GetAbsWeekDaysYearly(date, weekDay),
            _ => []
        };

        return GetOffsetDates(dates, weekDay.Offset);
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysDaily(LocalDateTime date, WeekDay weekDay)
        => (date.DayOfWeek.ToDayOfWeek() == weekDay.DayOfWeek) ? [date] : [];

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysYearly(LocalDateTime date, WeekDay weekDay)
    {
        var year = date.Year;
        var daysInYear = DateTime.IsLeapYear(year) ? 366 : 365;

        // Go to Jan 1 and find first occurrence of target weekday
        date = date.PlusDays(-date.DayOfYear + 1);
        var targetDayOfWeek = weekDay.DayOfWeek.ToIsoDayOfWeek();
        if (date.DayOfWeek != targetDayOfWeek)
        {
            date = date.Next(targetDayOfWeek);
        }

        // Yield all occurrences (52 or 53 per year)
        var occurrenceCount = (daysInYear - date.Day + 7) / 7;
        for (var i = 0; i < occurrenceCount; i++)
        {
            yield return date;
            date = date.PlusDays(7);
        }
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysMonthly(LocalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var daysInMonth = date.Calendar.GetDaysInMonth(date.Year, date.Month);

        // Go to first day of month and find first occurrence of target weekday
        date = date.PlusDays(-date.Day + 1);
        var targetDayOfWeek = weekDay.DayOfWeek.ToIsoDayOfWeek();
        if (date.DayOfWeek != targetDayOfWeek)
        {
            date = date.Next(targetDayOfWeek);
        }

        // Pre-calculate occurrence count (4 or 5 occurrences per month)
        var occurrenceCount = (daysInMonth - date.Day + 7) / 7;

        var weekYearRule = GetWeekYearRule(pattern);

        var byWeekNoNormalized = pattern.ByWeekNo.Count > 0
            ? GetByWeekNoForYearNormalized(pattern, weekYearRule.GetWeekYear(date.Date))
            : null;

        for (var i = 0; i < occurrenceCount; i++)
        {
            var matchesWeekNo = byWeekNoNormalized == null || byWeekNoNormalized.Contains(weekYearRule.GetWeekOfWeekYear(date.Date));
            var matchesMonth = pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month);

            if (matchesWeekNo && matchesMonth)
            {
                yield return date;
            }
            date = date.PlusDays(7);
        }
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysWeekly(LocalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var weekYearRule = GetWeekYearRule(pattern);

        var weekNo = weekYearRule.GetWeekOfWeekYear(date.Date);

        // Go to the first day of the week
        var weekDayOffset = GetWeekDayOffset(date, pattern.FirstDayOfWeek);
        date = date.PlusDays(-weekDayOffset);

        // Find first occurrence of target weekday
        var targetDayOfWeek = weekDay.DayOfWeek.ToIsoDayOfWeek();
        if (date.DayOfWeek != targetDayOfWeek)
        {
            date = date.Next(targetDayOfWeek);
        }

        var currentWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);
        var nextWeekNo = currentWeekNo;

        var byWeekNoNormalized = pattern.ByWeekNo.Count > 0
            ? GetByWeekNoForYearNormalized(pattern, weekYearRule.GetWeekYear(date.Date))
            : null;

        // When we manage weekly recurring pattern, and we have boundary case:
        // Weekdays: Dec 31, Jan 1, Feb 1, Mar 1, Apr 1, May 1, June 1, Dec 31 - 
        // It's the 53rd week of the year, but all others are 1st week number.
        while (currentWeekNo == weekNo || (nextWeekNo < weekNo && currentWeekNo == nextWeekNo && pattern.Frequency == FrequencyType.Weekly))
        {
            var matchesWeekNo = byWeekNoNormalized == null || byWeekNoNormalized.Contains(currentWeekNo);
            var matchesMonth = pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month);

            if (matchesWeekNo && matchesMonth)
            {
                yield return date;
            }

            date = date.PlusDays(7);
            currentWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);
        }
    }

    /// <summary>
    /// Returns the days since the start of the week, 0 if the date is on the first day of the week.
    /// </summary>
    private static int GetWeekDayOffset(LocalDateTime date, DayOfWeek startOfWeek)
        => date.DayOfWeek.ToDayOfWeek() + ((date.DayOfWeek.ToDayOfWeek() < startOfWeek) ? 7 : 0) - startOfWeek;

    /// <summary>
    /// Returns a single-element sublist containing the element of <paramref name="dates"/> at <paramref name="offset"/>. 
    /// Valid offsets are from 1 to the size of the list. If an invalid offset is supplied, all elements from <paramref name="dates"/>
    /// are added to result.
    /// </summary>
    /// <param name="dates">The list from which to extract the element.</param>
    /// <param name="offset">The position of the element to extract.</param>
    private static IEnumerable<LocalDateTime> GetOffsetDates(IEnumerable<LocalDateTime> dates, int? offset)
    {
        switch (offset)
        {
            case null:
                return dates;
            case 0:
                throw new EvaluationException("Encountered a day offset of 0 which is not allowed.");
            case < 0:
            {
                var list = dates as IList<LocalDateTime> ?? dates.ToList();
                var index = list.Count + offset.Value;
                return index >= 0 && index < list.Count
                    ? [list[index]]
                    : [];
            }
            default:
                return dates.Skip(offset.Value - 1).Take(1);
        }
    }

    /// <summary>
    /// Applies BYHOUR rules specified in this Recur instance to the specified date list. 
    /// If no BYHOUR rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYHOUR rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYHOUR rules.</returns>
    private static IEnumerable<ZonedDateTime> GetHourVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByHour.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByHour.Select(hour => date
                .LocalDateTime
                .With(x => new LocalTime(hour, x.Minute, x.Second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByHour.Contains(date.Hour));
    }

    /// <summary>
    /// Applies BYMINUTE rules specified in this Recur instance to the specified date list. 
    /// If no BYMINUTE rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMINUTE rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMINUTE rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMinuteVariants(
        IEnumerable<ZonedDateTime> dates,
        RecurrencePattern pattern,
        bool? expand)
    {
        if (expand == null || pattern.ByMinute.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByMinute.Select(minute => date
                .LocalDateTime
                .With(x => new LocalTime(x.Hour, minute, x.Second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByMinute.Contains(date.Minute));
    }

    /// <summary>
    /// Applies BYSECOND rules specified in this Recur instance to the specified date list. 
    /// If no BYSECOND rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSECOND rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYSECOND rules.</returns>
    private static IEnumerable<ZonedDateTime> GetSecondVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.BySecond.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.BySecond.Select(second => date
                .LocalDateTime
                .With(x => new LocalTime(x.Hour, x.Minute, second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.BySecond.Contains(date.Second));
    }

    /// <summary>
    /// Evaluate the occurrences of this recurrence pattern.
    /// </summary>
    /// <param name="referenceDate">The reference date, i.e. DTSTART.</param>
    /// <param name="periodStart">Start (incl.) of the period occurrences are generated for.</param>
    /// <param name="options"></param>
    /// <returns></returns>
    public override IEnumerable<EvaluationPeriod> Evaluate(CalDateTime referenceDate, DateTimeZone timeZone, Instant? periodStart, EvaluationOptions? options)
    {
        if (Pattern.Frequency < FrequencyType.Daily && !referenceDate.HasTime)
        {
            // This case is not defined by RFC 5545. We handle it by evaluating the rule
            // as if referenceDate had a time (i.e. set to midnight).
            referenceDate = new CalDateTime(referenceDate.Date, new TimeOnly(), referenceDate.TzId);
        }

        // Create a recurrence pattern suitable for use during evaluation.
        var pattern = ProcessRecurrencePattern(referenceDate);

        var periodQuery = GetDates(referenceDate, timeZone, periodStart, pattern, options)
            .Select(dt => new EvaluationPeriod(dt));

        if (pattern.Until is not null)
        {
            var until = pattern.Until.ToZonedDateTime(timeZone).ToInstant();

            periodQuery = periodQuery.TakeWhile(p => p.Start.ToInstant() <= until);
        }

        return periodQuery;
    }
}
