//
// Copyright ical.net project maintainers and contributors.
// Licensed under the MIT license.
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Ical.Net.DataTypes;

namespace Ical.Net.Evaluation;

public class RecurrencePatternEvaluator : Evaluator
{
    /// <summary>
    /// The system calendar to be used to calculate details like the week of the year, days in a month, etc.
    /// We only support the gregorian calendar at this time. We take it from the InvariantCulture to avoid
    /// any side effects from the local system's configuration.
    /// </summary>
    private static System.Globalization.Calendar Calendar { get; } = System.Globalization.CultureInfo.InvariantCulture.Calendar;

    protected RecurrencePattern Pattern { get; set; }

    public RecurrencePatternEvaluator(RecurrencePattern pattern)
    {
        Pattern = pattern;
    }

    private RecurrencePattern ProcessRecurrencePattern(CalDateTime referenceDate)
    {
        var r = new RecurrencePattern();
        r.CopyFrom(Pattern);

        if (referenceDate.HasTime)
        {
            if (r.Frequency > FrequencyType.Secondly && r.BySecond.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.BySecond.Add(referenceDate.Second);
            }
            if (r.Frequency > FrequencyType.Minutely && r.ByMinute.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByMinute.Add(referenceDate.Minute);
            }
            if (r.Frequency > FrequencyType.Hourly && r.ByHour.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByHour.Add(referenceDate.Hour);
            }
        }
        else
        {
            // The BYSECOND, BYMINUTE and BYHOUR rule parts MUST NOT be specified
            // when the associated "DTSTART" property has a DATE value type.
            // These rule parts MUST be ignored in RECUR value that violate the
            // above requirement(e.g., generated by applications that pre - date
            // this revision of iCalendar).
            r.BySecond.Clear();
            r.BySecond.Add(0);
            r.ByMinute.Clear();
            r.ByMinute.Add(0);
            r.ByHour.Clear();
            r.ByHour.Add(0);
        }

        // If BYDAY, BYYEARDAY, or BYWEEKNO is specified, then
        // we don't default BYDAY, BYMONTH or BYMONTHDAY
        if (r.ByDay.Count == 0)
        {
            // If the frequency is weekly, use the original date's day of week.
            // NOTE: fixes WeeklyCount1() and WeeklyUntil1() handling
            // If BYWEEKNO is specified and BYMONTHDAY/BYYEARDAY is not specified,
            // then let's add BYDAY to BYWEEKNO.
            // NOTE: fixes YearlyByWeekNoX() handling
            if (r.Frequency == FrequencyType.Weekly || (r.ByWeekNo.Count > 0 && r.ByMonthDay.Count == 0 && r.ByYearDay.Count == 0))
            {
                r.ByDay.Add(new WeekDay(referenceDate.DayOfWeek));
            }

            // If BYMONTHDAY is not specified,
            // default to the current day of month.
            // NOTE: fixes YearlyByMonth1() handling, added BYYEARDAY exclusion
            // to fix YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Weekly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonthDay.Count == 0)
            {
                r.ByMonthDay.Add(referenceDate.Day);
            }

            // If BYMONTH is not specified, default to
            // the current month.
            // NOTE: fixes YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Monthly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonth.Count == 0)
            {
                r.ByMonth.Add(referenceDate.Month);
            }
        }

        // Pre-order those BY values that don't allow for negative values. Those with negative values can only
        // be ordered once the individual position is known.
        if (r.BySecond.Count > 0) r.BySecond = r.BySecond.OrderBy(x => x).ToList();
        if (r.ByMinute.Count > 0) r.ByMinute = r.ByMinute.OrderBy(x => x).ToList();
        if (r.ByHour.Count > 0) r.ByHour = r.ByHour.OrderBy(x => x).ToList();
        if (r.ByMonth.Count > 0) r.ByMonth = r.ByMonth.OrderBy(x => x).ToList();

        return r;
    }

    /// <summary>
    /// Returns a list of start dates in the specified period represented by this recurrence pattern.
    /// This method includes a base date argument, which indicates the start of the first occurrence of this recurrence.
    /// The base date is used to inject default values to return a set of dates in the correct format.
    /// For example, if the search start date (start) is Wed, Mar 23, 12:19PM, but the recurrence is Mon - Fri, 9:00AM - 5:00PM,
    /// the start dates returned should all be at 9:00AM, and not 12:19PM.
    /// </summary>
    private IEnumerable<CalDateTime> GetDates(CalDateTime seed, CalDateTime? periodStart, RecurrencePattern pattern,
         EvaluationOptions? options)
    {
        var originalDate = seed;
        var seedCopy = seed;
        var periodStartDt = periodStart?.ToTimeZone(seed.TzId);

        if ((pattern.Frequency == FrequencyType.Yearly) && (pattern.ByWeekNo.Count != 0))
        {
            // Dates in the first or last week of the year could belong weeks that belong to
            // the prev/next year, in which case we must adjust that year. This is necessary
            // to get the intervals right.
            IncrementDate(ref seedCopy, pattern, Calendar.GetIso8601YearOfWeek(seedCopy, pattern.FirstDayOfWeek) - seedCopy.Year);
        }

        // optimize the start time for selecting candidates
        // (only applicable where a COUNT is not specified)
        if (pattern.Count is null)
        {
            var incremented = seedCopy;
            while (incremented < periodStartDt)
            {
                seedCopy = incremented;
                IncrementDate(ref incremented, pattern, pattern.Interval);
            }
        } else
        {
            if (pattern.Count < 1)
                throw new Exception("Count must be greater than 0");
        }

        // Do the enumeration in a separate method, as it is a generator method that is
        // only executed after enumeration started. In order to do most validation upfront,
        // do as many steps outside the generator as possible.
        return EnumerateDates(originalDate, seedCopy, pattern, options);
    }

    private IEnumerable<CalDateTime> EnumerateDates(CalDateTime originalDate, CalDateTime intervalRefTime, RecurrencePattern pattern, EvaluationOptions? options)
    {
        var expandBehavior = RecurrenceUtil.GetExpandBehaviorList(pattern);

        var searchEndDate = GetSearchEndDate(pattern);

        var noCandidateIncrementCount = 0;

        var dateCount = 0;
        while (true)
        {
            var lowerLimit = GetIntervalLowerLimit(intervalRefTime, pattern, originalDate);

            if (searchEndDate < lowerLimit)
                break;

            var candidates =
                GetCandidates((lowerLimit > intervalRefTime) ? lowerLimit : intervalRefTime, pattern, expandBehavior);

            foreach (var t in candidates.Where(t => t >= originalDate))
            {
                noCandidateIncrementCount = 0;
                var candidate = t;

                // candidates MAY occur before periodStart
                // For example, FREQ=YEARLY;BYWEEKNO=1 could return dates
                // from the previous year.

                // UNTIL is applied outside of this method, after TZ conversion has been applied.

                yield return candidate;
                dateCount++;

                if (dateCount >= pattern.Count)
                    yield break;
            }

            if (noCandidateIncrementCount > options?.MaxUnmatchedIncrementsLimit)
                throw new EvaluationLimitExceededException();

            noCandidateIncrementCount++;

            IncrementDate(ref intervalRefTime, pattern, pattern.Interval);
        }
    }

    private static CalDateTime? GetSearchEndDate(RecurrencePattern pattern)
    {
        // This value is only used for performance reasons to stop incrementing after
        // until is passed, even if no recurrences are being found.
        // As a safe heuristic we add 1d to the UNTIL value to cover any time shift and DST changes.
        // It's just important that we don't miss any recurrences, not that we stop exactly at UNTIL.
        // Precise UNTIL handling is done outside this method after TZ conversion.
        var coarseUntil = pattern.Until?.AddDays(1);

        return coarseUntil;
    }

    /// <summary>
    /// Find the lowest possible date/time for a recurrence in the given interval.
    /// </summary>
    /// <remarks>
    /// For most frequencies the interval's lower limit is simply the provided
    /// <paramref name="intervalRefTime"/>. YEARLY rules require special handling:
    /// - If BYMONTH is present and BYWEEKNO is not, an occurrence for the interval
    ///   might fall earlier in the year than the intervalRefTime's month/day. In
    ///   that case we compute the earliest possible date/time that could be
    ///   generated for the interval (earliest month/day/hour/minute/second).
    /// - If neither BYMONTH nor BYWEEKNO is present, we use the original date's month
    /// - If only BYWEEKNO is present, the interval may contain days from the previous
    ///   or next year (ISO week boundaries). In that case we adjust the interval
    ///   start to the first day of the configured week so we don't miss candidates
    ///   that belong to the week containing Jan 1st.
    /// </remarks>
    private static CalDateTime GetIntervalLowerLimit(CalDateTime intervalRefTime, RecurrencePattern pattern, CalDateTime originalDate)
    {
        switch (pattern)
        {
            case { Frequency: FrequencyType.Yearly, ByMonth.Count: 0, ByWeekNo.Count: 0 }:
            {
                // Return intervalRefTime but use the month from the original DTSTART.
                // Else, the earliest candidate for the interval might be too early
                // Do this by shifting the intervalRefTime by the difference in months.
                // This preserves the day/time from intervalRefTime and relies on AddMonths
                // to perform month-end semantics (e.g. Jan 31 -> Feb 28/29) instead of
                // manually clamping the day.
                var monthDelta = originalDate.Month - intervalRefTime.Month;
                var adjusted = intervalRefTime.AddMonths(monthDelta);

                return new CalDateTime(adjusted.Year, adjusted.Month, adjusted.Day, adjusted.Hour, adjusted.Minute, adjusted.Second, intervalRefTime.TzId);
            }

            case { Frequency: FrequencyType.Yearly, ByMonth.Count: > 0, ByWeekNo.Count: 0 }:
            {
                // When evaluating a YEARLY rule that restricts months (BYMONTH) but not
                // week numbers, it's possible that the earliest candidate inside the
                // interval is in an earlier month/day than `intervalRefTime` (for example
                // BYMONTH=1 while intervalRefTime is anchored on a later month). To avoid
                // terminating enumeration prematurely (with a coarse UNTIL cutoff), compute
                // the earliest plausible date/time for this interval and use that as the
                // lower limit.
                //
                // We pick:
                //  - year = intervalRefTime.Year
                //  - month = smallest BYMONTH or the original DTSTART month if BYMONTH absent
                //  - day = smallest BYMONTHDAY (clamped to daysInMonth) or original DTSTART day
                //  - time components = smallest BYHOUR/BYMINUTE/BYSECOND or original DTSTART time
                //
                // This is a conservative earliest-possible candidate; it must not exclude
                // any valid occurrence for the interval.
                var year = intervalRefTime.Year;

                // Determine the earliest month we could possibly generate for this interval.
                var month = pattern.ByMonth.Min();

                // Determine an appropriate day in the month.
                var daysInMonth = Calendar.GetDaysInMonth(year, month);
                int day;
                if (pattern.ByMonthDay.Count > 0)
                {
                    // Map BYMONTHDAY entries (positive and negative) to absolute days
                    // in the target month, then pick the smallest. This handles cases
                    // where BYMONTHDAY mixes positive and negative values (e.g. 2,-2).
                    var mappedDays = pattern.ByMonthDay
                        .Select(md => md > 0 ? Math.Min(md, daysInMonth) : Math.Max(1, daysInMonth + md + 1));
                    day = mappedDays.Min();
                }
                else
                {
                    // default to original date's day, constrained to the target month length
                    day = Math.Min(originalDate.Day, daysInMonth);
                }

                // Determine earliest time components
                var hour = pattern.ByHour.Count > 0 ? pattern.ByHour.Min() : originalDate.Hour;
                var minute = pattern.ByMinute.Count > 0 ? pattern.ByMinute.Min() : originalDate.Minute;
                var second = pattern.BySecond.Count > 0 ? pattern.BySecond.Min() : originalDate.Second;

                return new CalDateTime(year, month, day, hour, minute, second, intervalRefTime.TzId);
            }

            case { Frequency: FrequencyType.Yearly, ByWeekNo.Count: not 0 }:
            {
                // YEARLY with BYWEEKNO: weeks may span year boundaries. Move the
                // interval lower limit to the first day of the week so expansion over
                // the week (including days before Jan 1st) is handled correctly.
                return GetFirstDayOfWeekDate(intervalRefTime, pattern.FirstDayOfWeek);
            }

            default:
            {
                return intervalRefTime;
            }
        }
    }

    private struct ExpandContext
    {
        /// <summary>
        /// Indicates whether the dates have been fully expanded. If true, subsequent parts should only limit, not expand.
        /// </summary>
        /// <remarks>
        /// This makes a difference in case of BYWEEKNO, which might span months and years. After it was applied (BYWEEKNO would
        /// always expand), the subsequent parts mustn't expand.
        /// </remarks>
        public bool DatesFullyExpanded { get; set; }
    }

    /// <summary>
    /// Returns a list of possible dates generated from the applicable BY* rules, using the specified date as a seed.
    /// </summary>
    /// <param name="date">The seed date.</param>
    /// <param name="pattern"></param>
    /// <param name="expandBehaviors"></param>
    /// <returns>A list of possible dates.</returns>
    private IEnumerable<CalDateTime> GetCandidates(CalDateTime date, RecurrencePattern pattern, bool?[] expandBehaviors)
    {
        var expandContext = new ExpandContext() { DatesFullyExpanded = false };

        IEnumerable<CalDateTime> dates = [date];
        dates = GetMonthVariants(dates, pattern, expandBehaviors[0]);
        dates = GetWeekNoVariants(dates, pattern, expandBehaviors[1], ref expandContext);
        dates = GetYearDayVariants(dates, pattern, expandBehaviors[2], ref expandContext);
        dates = GetMonthDayVariants(dates, pattern, expandBehaviors[3], ref expandContext);
        dates = GetDayVariants(dates, pattern, expandBehaviors[4], ref expandContext);
        dates = GetHourVariants(dates, pattern, expandBehaviors[5]);
        dates = GetMinuteVariants(dates, pattern, expandBehaviors[6]);
        dates = GetSecondVariants(dates, pattern, expandBehaviors[7]);
        dates = ApplySetPosRules(dates, pattern);

        return dates;
    }

    /// <summary>
    /// Applies BYSETPOS rules to <paramref name="dates"/>. Valid positions are from 1 to the size of the date list. Invalid
    /// positions are ignored.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSETPOS rules will be applied.</param>
    /// <param name="pattern"></param>
    private static IEnumerable<CalDateTime> ApplySetPosRules(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        // return if no SETPOS rules specified..
        if (pattern.BySetPosition.Count == 0)
            return dates;

        ISet<int> bySetPos;

        if (pattern.BySetPosition.Any(p => p < 0)) {
            var tmp = dates.ToList();
            var count = tmp.Count;
            dates = tmp;
            bySetPos = new HashSet<int>(
                pattern.BySetPosition
                .Select(p => (p < 0) ? count + p + 1 : p));
        } else {
            bySetPos = new HashSet<int>(pattern.BySetPosition);
        }

        return dates.Where((d, i) => bySetPos.Contains(i + 1));
    }

    /// <summary>
    /// Applies BYMONTH rules specified in this Recur instance to the specified date list. 
    /// If no BYMONTH rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMONTH rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMONTH rules.</returns>
    private static IEnumerable<CalDateTime> GetMonthVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByMonth.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates
                .SelectMany(d => pattern.ByMonth.Select(month => d.AddMonths(month - d.Month)));
        }

        // Limit behavior
        if (pattern.Frequency == FrequencyType.Weekly)
        {
            // The dates here represent weeks, with each date being the
            // start of a week except for the initial reference date.
            // Return weeks that have any day within BYMONTH.
            return dates.Where(date => pattern.ByMonth.Contains(date.Month)
                || pattern.ByMonth.Contains(date.AddDays(6).Month));
        }

        return dates.Where(date => pattern.ByMonth.Contains(date.Month));
    }

    /// <summary>
    /// Applies BYWEEKNO rules specified in this Recur instance to the specified date list. 
    /// If no BYWEEKNO rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYWEEKNO rules will be applied.</param>
    /// <returns>The modified list of dates after applying the BYWEEKNO rules.</returns>
    private static IEnumerable<CalDateTime> GetWeekNoVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByWeekNo.Count == 0)
            return dates;

        Debug.Assert(expand.Value);

        // Expand behavior
        var weekNoDates = GetWeekNoVariantsExpanded(dates, pattern);

        // subsequent parts should only limit, not expand
        expandContext.DatesFullyExpanded = true;

        // Apply BYMONTH limit behavior, as we might have expanded over month/year boundaries
        // in this method and BYMONTH has already been applied before, so wouldn't be again.
        return GetMonthVariants(weekNoDates, pattern, expand: false);
    }

    private static IEnumerable<CalDateTime> GetWeekNoVariantsExpanded(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var (t, weekNo) in dates.SelectMany(t => GetByWeekNoForYearNormalized(pattern, t.Year), (t, weekNo) => (t, weekNo)))
        {
            var date = t;

            // Make sure we start from a reference date that is in a week that belongs to the current year.
            // It's not important that the date lies in a certain week, but that the week belongs to the
            // current year and that the week day is preserved.
            if (date.Month == 1)
                date = date.AddDays(7);
            else if (date.Month >= 12)
                date = date.AddDays(-7);

            // Determine our current week number
            var currWeekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);

            // Move ahead to the correct week of the year
            date = date.AddDays((weekNo - currWeekNo) * 7);

            // Ignore the week if it doesn't belong to the current year.
            if (Calendar.GetIso8601YearOfWeek(date, pattern.FirstDayOfWeek) != t.Year)
                continue;

            // Step backward single days until we're at the correct DayOfWeek
            date = GetFirstDayOfWeekDate(date, pattern.FirstDayOfWeek);

            foreach (var d in Enumerable.Range(0, 7).Select(i => date.AddDays(i)))
                yield return d;
        }
    }

    private static CalDateTime GetFirstDayOfWeekDate(CalDateTime date, DayOfWeek firstDayOfWeek)
        => date.AddDays(-((int) date.DayOfWeek + 7 - (int) firstDayOfWeek) % 7);

    /// <summary>
    /// Normalize the BYWEEKNO values to be positive integers.
    /// </summary>
    private static List<int> GetByWeekNoForYearNormalized(RecurrencePattern pattern, int year)
    {
        var weeksInYear = new Lazy<int>(() => Calendar.GetIso8601WeeksInYear(year, pattern.FirstDayOfWeek));
        return pattern.ByWeekNo
            .Select(weekNo => weekNo >= 0 ? weekNo : weeksInYear.Value + weekNo + 1)
            .OrderBy(x => x)
            .ToList();
    }

    /// <summary>
    /// Applies <c>BYYEARDAY</c> rules from <paramref name="pattern"/> to a sequence of candidate dates.
    /// </summary>
    /// <param name="dates">Sequence of candidate dates (typically interval reference dates or previously-expanded dates).</param>
    /// <param name="pattern">Recurrence pattern containing the <c>BYYEARDAY</c> values.</param>
    /// <param name="expand">
    /// Controls the operation mode:
    /// - <c>true</c>  : perform an expand operation — each input date is expanded into the concrete dates
    ///                  represented by the <c>BYYEARDAY</c> values for that date's year.
    /// - <c>false</c> : perform a limit/filter operation — only return input dates that match any of the
    ///                  <c>BYYEARDAY</c> values for the input date's year.
    /// - <c>null</c>  : no operation, return <paramref name="dates"/> unchanged.
    /// </param>
    /// <param name="expandContext">
    /// Context that indicates whether earlier parts have already fully expanded the candidate set.
    /// If <see cref="ExpandContext.DatesFullyExpanded"/> is <c>true</c> then expansion must not be
    /// performed again and the method should behave in limit mode.
    /// When this method performs an expansion it will set <see cref="ExpandContext.DatesFullyExpanded"/>
    /// to <c>true</c> to prevent later parts from expanding again.
    /// </param>
    /// <returns>
    /// A sequence of dates after applying the <c>BYYEARDAY</c> rules.
    /// Expanded dates produced for a given input are constrained to the same calendar year as the input date;
    /// out-of-range <c>BYYEARDAY</c> values (e.g. +-366 in non-leap years) are ignored.
    /// </returns>
    private static IEnumerable<CalDateTime> GetYearDayVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand is null || pattern.ByYearDay.Count == 0)
            return dates;

        if ((expand == true) && !expandContext.DatesFullyExpanded)
        {
            expandContext.DatesFullyExpanded = true;
            return GetYearDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetYearDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<CalDateTime> GetYearDayVariantsExpanded(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var date1 = date;
            var yearDayDates = new SortedSet<CalDateTime>(
                pattern.ByYearDay.Select(yearDay => yearDay > 0
                ? date1.AddDays(-date1.DayOfYear + yearDay)
                : date1.AddDays(-date1.DayOfYear + 1).AddYears(1).AddDays(yearDay))
                // Ignore the BY values that don't fit into the current year (i.e. +-366 in non-leap-years).
                .Where(d => d.Year == date1.Year));

            foreach (var d in yearDayDates)
                yield return d;
        }
    }

    private static IEnumerable<CalDateTime> GetYearDayVariantsLimited(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var candidates =
                from yearDay in pattern.ByYearDay
                let newDate = yearDay > 0
                    ? date.AddDays(-date.DayOfYear + yearDay)
                    : date.AddDays(-date.DayOfYear + 1).AddYears(1).AddDays(yearDay)
                select newDate;

            if (candidates.Contains(date))
                yield return date;
        }
    }

    /// <summary>
    /// Applies BYMONTHDAY rules specified in this RecurrencePattern instance to the specified date list. 
    /// If no BYMONTHDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <returns>The modified list of dates after applying the BYMONTHDAY rules.</returns>
    private static IEnumerable<CalDateTime> GetMonthDayVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByMonthDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.DatesFullyExpanded)
        {
            expandContext.DatesFullyExpanded = true;
            return GetMonthDayVariantsExpanded(dates, pattern);
        }

        // limit behavior
        return GetMonthDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<CalDateTime> GetMonthDayVariantsLimited(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        // Helper that checks whether the given candidate matches any BYMONTHDAY entry
        // taking negative values into account (relative to the month's length).
        static bool MatchesAnyMonthDay(CalDateTime candidate, IEnumerable<int> monthDays)
        {
            var daysInMonth = Calendar.GetDaysInMonth(candidate.Year, candidate.Month);
            foreach (var monthDay in monthDays)
            {
                var byMonthDay = monthDay > 0 ? monthDay : (daysInMonth + monthDay + 1);
                if (candidate.Day == byMonthDay)
                    return true;
            }
            return false;
        }

        foreach (var date in dates)
        {
            // If BYMONTH is specified and this date's month is not included, skip it.
            if (pattern.ByMonth.Count > 0 && !pattern.ByMonth.Contains(date.Month))
                continue;

            if (MatchesAnyMonthDay(date, pattern.ByMonthDay))
                yield return date;
        }
    }

    private static IEnumerable<CalDateTime> GetMonthDayVariantsExpanded(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var monthDayDates = new SortedSet<CalDateTime>(
                from monthDay in pattern.ByMonthDay
                let daysInMonth = Calendar.GetDaysInMonth(date.Year, date.Month)
                let monthDayAbs = (monthDay > 0) ? monthDay : (daysInMonth + monthDay + 1)
                where (monthDayAbs > 0) && (monthDayAbs <= daysInMonth)
                select date.AddDays(-date.Day + monthDayAbs));

            foreach (var d in monthDayDates)
                yield return d;
        }
    }

    /// <summary>
    /// Applies BYDAY rules specified in this Recur instance to the specified date list. 
    /// If no BYDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which BYDAY rules will be applied.</param>
    /// <returns>The modified list of dates after applying BYDAY rules, or the original list if no BYDAY rules are specified.</returns>
    private static IEnumerable<CalDateTime> GetDayVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.DatesFullyExpanded)
        {
            // Expand behavior
            expandContext.DatesFullyExpanded = true;
            return GetDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<CalDateTime> GetDayVariantsLimited(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
        =>
        // If no offset is specified, simply test the day of week!
        // FIXME: test with offset...
        dates.Where(date => pattern.ByDay.Any(weekDay => weekDay.DayOfWeek.Equals(date.DayOfWeek)));

    private static IEnumerable<CalDateTime> GetDayVariantsExpanded(IEnumerable<CalDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var weekDayDates = new SortedSet<CalDateTime>();
            foreach (var day in pattern.ByDay)
                foreach (var d in GetAbsWeekDays(date, day, pattern))
                    weekDayDates.Add(d);

            foreach (var d in weekDayDates)
                yield return d;
        }
    }

    /// <summary>
    /// Returns a list of applicable dates corresponding to the specified week day in accordance with the frequency
    /// specified by this recurrence rule.
    /// </summary>
    /// <param name="date">The date to start the evaluation from.</param>
    /// <param name="weekDay">The week day to evaluate.</param>
    /// <returns>A list of applicable dates.</returns>
    private static IEnumerable<CalDateTime> GetAbsWeekDays(CalDateTime date, WeekDay weekDay, RecurrencePattern pattern)
    {
        var dates = pattern switch
        {
            { Frequency: FrequencyType.Daily } => GetAbsWeekDaysDaily(date, weekDay),
            { Frequency: FrequencyType.Weekly } or { ByWeekNo: { Count: > 0 } } => GetAbsWeekDaysWeekly(date, pattern, weekDay),
            { Frequency: FrequencyType.Monthly } or { ByMonth: { Count: > 0 } } => GetAbsWeekDaysMonthly(date, pattern, weekDay),
            { Frequency: FrequencyType.Yearly } => GetAbsWeekDaysYearly(date, weekDay),
            _ => []
        };

        return GetOffsetDates(dates, weekDay.Offset);
    }

    private static IEnumerable<CalDateTime> GetAbsWeekDaysDaily(CalDateTime date, WeekDay weekDay)
        => (date.DayOfWeek == weekDay.DayOfWeek) ? [date] : [];

    private static IEnumerable<CalDateTime> GetAbsWeekDaysYearly(CalDateTime date, WeekDay weekDay)
    {
        var year = date.Year;

        // construct a list of possible year days..
        date = date.AddDays(-date.DayOfYear + 1);
        while (date.DayOfWeek != weekDay.DayOfWeek)
        {
            date = date.AddDays(1);
        }

        while (date.Year == year)
        {
            yield return date;
            date = date.AddDays(7);
        }
    }

    private static IEnumerable<CalDateTime> GetAbsWeekDaysMonthly(CalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var month = date.Month;

        // construct a list of possible month days..
        date = date.AddDays(-date.Day + 1);
        while (date.DayOfWeek != weekDay.DayOfWeek)
        {
            date = date.AddDays(1);
        }

        var byWeekNoNormalized = GetByWeekNoForYearNormalized(pattern, Calendar.GetIso8601YearOfWeek(date, pattern.FirstDayOfWeek));
        while (date.Month == month)
        {
            var currentWeekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);

            if ((byWeekNoNormalized.Count == 0 || byWeekNoNormalized.Contains(currentWeekNo))
                && (pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month)))
            {
                yield return date;
            }
            date = date.AddDays(7);
        }
    }

    private static IEnumerable<CalDateTime> GetAbsWeekDaysWeekly(CalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var weekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);

        // Go to the first day of the week
        date = date.AddDays(-GetWeekDayOffset(date, pattern.FirstDayOfWeek));

        // construct a list of possible week days..
        while (date.DayOfWeek != weekDay.DayOfWeek)
        {
            date = date.AddDays(1);
        }

        var nextWeekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);
        var currentWeekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);
        var byWeekNoNormalized = GetByWeekNoForYearNormalized(pattern, Calendar.GetIso8601YearOfWeek(date, pattern.FirstDayOfWeek));

        //When we manage weekly recurring pattern and we have boundary case:
        //Weekdays: Dec 31, Jan 1, Feb 1, Mar 1, Apr 1, May 1, June 1, Dec 31 - It's the 53th week of the year, but all another are 1st week number.
        while (currentWeekNo == weekNo || (nextWeekNo < weekNo && currentWeekNo == nextWeekNo && pattern.Frequency == FrequencyType.Weekly))
        {
            if ((byWeekNoNormalized.Count == 0 || byWeekNoNormalized.Contains(currentWeekNo))
                && (pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month)))
            {
                yield return date;
            }

            date = date.AddDays(7);
            currentWeekNo = Calendar.GetIso8601WeekOfYear(date, pattern.FirstDayOfWeek);
        }
    }

    /// <summary>
    /// Returns the days since the start of the week, 0 if the date is on the first day of the week.
    /// </summary>
    private static int GetWeekDayOffset(CalDateTime date, DayOfWeek startOfWeek)
        => date.DayOfWeek + ((date.DayOfWeek < startOfWeek) ? 7 : 0) - startOfWeek;

    /// <summary>
    /// Returns a single-element sublist containing the element of <paramref name="dates"/> at <paramref name="offset"/>. 
    /// Valid offsets are from 1 to the size of the list. If an invalid offset is supplied, all elements from <paramref name="dates"/>
    /// are added to result.
    /// </summary>
    /// <param name="dates">The list from which to extract the element.</param>
    /// <param name="offset">The position of the element to extract.</param>
    private static IEnumerable<CalDateTime> GetOffsetDates(IEnumerable<CalDateTime> dates, int? offset)
    {
        if (offset is null)
            return dates;

        if (offset == 0)
            throw new EvaluationException("Encountered a day offset of 0 which is not allowed.");

        if (offset < 0) {
            offset = -offset;
            dates = dates.Reverse();
        }

        return dates.Skip(offset.Value - 1).Take(1);
    }

    /// <summary>
    /// Applies BYHOUR rules specified in this Recur instance to the specified date list. 
    /// If no BYHOUR rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYHOUR rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYHOUR rules.</returns>
    private static IEnumerable<CalDateTime> GetHourVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByHour.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByHour.Select(hour => date.AddHours(-date.Hour + hour)));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByHour.Contains(date.Hour));
    }

    /// <summary>
    /// Applies BYMINUTE rules specified in this Recur instance to the specified date list. 
    /// If no BYMINUTE rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMINUTE rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMINUTE rules.</returns>
    private static IEnumerable<CalDateTime> GetMinuteVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByMinute.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByMinute.Select(minute => date.AddMinutes(-date.Minute + minute)));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByMinute.Contains(date.Minute));
    }

    /// <summary>
    /// Applies BYSECOND rules specified in this Recur instance to the specified date list. 
    /// If no BYSECOND rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSECOND rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYSECOND rules.</returns>
    private static IEnumerable<CalDateTime> GetSecondVariants(IEnumerable<CalDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.BySecond.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.BySecond.Select(second => date.AddSeconds(-date.Second + second)));
        }

        // Limit behavior
        return dates.Where(date => pattern.BySecond.Contains(date.Second));
    }

    /// <summary>
    /// Creates a new period from the specified date/time,
    /// where the <see cref="CalDateTime.HasTime"/> is taken into account.
    /// when initializing the new period with a new <see cref="CalDateTime"/>.
    /// </summary>
    private static Period CreatePeriod(CalDateTime dateTime, CalDateTime referenceDate)
    {
        // Turn each resulting date/time into an CalDateTime and associate it
        // with the reference date.
        var newDt = new CalDateTime(dateTime.Value, null, referenceDate.HasTime);
        if (referenceDate.TzId != null) {
            // Adjust nonexistent recurrence instances according to RFC 5545 3.3.5
            newDt = newDt.ToTimeZone(referenceDate.TzId);
        }

        // Create a period from the new date/time.
        return new Period(newDt);
    }

    /// <summary>
    /// Evaluate the occurrences of this recurrence pattern.
    /// </summary>
    /// <param name="referenceDate">The reference date, i.e. DTSTART.</param>
    /// <param name="periodStart">Start (incl.) of the period occurrences are generated for.</param>
    /// <param name="options"></param>
    /// <returns></returns>
    public override IEnumerable<Period> Evaluate(CalDateTime referenceDate, CalDateTime? periodStart, EvaluationOptions? options)
    {
        if (Pattern.Frequency < FrequencyType.Daily && !referenceDate.HasTime)
        {
            // This case is not defined by RFC 5545. We handle it by evaluating the rule
            // as if referenceDate had a time (i.e. set to midnight).
            referenceDate = new CalDateTime(referenceDate.Date, new TimeOnly(), referenceDate.TzId);
        }

        // Create a recurrence pattern suitable for use during evaluation.
        var pattern = ProcessRecurrencePattern(referenceDate);

        var periodQuery = GetDates(referenceDate, periodStart, pattern, options)
            .Select(dt => CreatePeriod(dt, referenceDate));

        if (pattern.Until is not null)
            periodQuery = periodQuery.TakeWhile(p => p.StartTime <= pattern.Until);

        return periodQuery;
    }
}
